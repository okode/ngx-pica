{"version":3,"sources":["ng://@digitalascetic/ngx-pica/lib/ngx-pica-error.interface.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica-exif.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica-image.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica.module.ts"],"names":["NgxPicaExifService","prototype","getExifOrientedImage","image","Promise","resolve","reject","EXIF.getData","exifOrientation","EXIF.getAllTags","Orientation","test","Error","canvas","document","createElement","ctx","getContext","deg","cx","cy","width","height","indexOf","translate","scale","rotate","Math","PI","drawImage","img_1","Image","onload","src","toDataURL","Injectable","NgxPicaService","_ngxPicaExifService","this","picaResizer","Pica","MAX_STEPS","resize","window","resizeImages","files","options","_this","resizedImage","Subject","totalFiles","length","nextFile_1","index_1","subscription_1","subscribe","file","resizeImage","imageResized","next","complete","unsubscribe","err","ngxPicaError","error","NgxPicaErrorType","asObservable","originCanvas","img","then","orientedImage","URL","revokeObjectURL","imageData","getImageData","aspectRatio","keepAspectRatio","ratio","forceMinDimensions","max","min","round","destinationCanvas","picaResize","catch","imgResized","createObjectURL","compressImages","sizeInMB","compressedImage","nextFile_2","index_2","subscription_2","compressImage","imageCompressed","bytesToMB","size","setTimeout","originCanvas_1","ctx_1","getCompressedImage","type","blob","imgCompressed","blobToFile","name","Date","getTime","quality","step","toBlob","checkCompressedImageSize","compressedBlob","newQuality","newStep","from","to","resizedCanvas","fileResized","lastModified","File","bytes","NgxPicaImageService","imageExtensions","isImage","fileExtension","toLowerCase","substr","lastIndexOf","NgxPicaModule","NgModule","args","providers","provide","useClass"],"mappings":"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OAAAtE,EAAKR,YAAYuE,OAAOO,EAAe7D,EAAK6C,QACvFhC,KAAI,SAAEiC,OACGgB,EAAoBvE,EAAKyD,WAAWF,EAAM9C,EAAKiD,KAAMjD,EAAK6C,MAAM,IAAIK,MAAOC,WACjFtG,EAAQiH,QAKhBlF,EAAAnC,UAAAuG,WAAR,SAAmBF,EAAYG,EAAcJ,EAAckB,GACvD,OAAO,IAAIC,KAAK,CAAClB,GAAOG,EAAM,CAAEJ,KAAMA,EAAMkB,aAAcA,KAGtDnF,EAAAnC,UAAA8F,UAAR,SAAkB0B,GACd,OAAOA,EAAQ,6BA9PtBtF,EAAAA,sDALQnC,KAqQToC,EAzQA,GCAAsF,EAAA,WAEA,SAAAA,IAGYpF,KAAAqF,gBAA4B,CAChC,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,OACA,KACA,MACA,OACA,MACA,MACA,MACA,OAOR,OAJWD,EAAAzH,UAAA2H,QAAP,SAAepE,OACLqE,EAAwBrE,EAAKiD,KAAKqB,cAAcC,OAAOvE,EAAKiD,KAAKuB,YAAY,KAAO,GAC1F,OAAyD,IAAjD1F,KAAKqF,gBAAgBpG,QAAQsG,wBAhI5C1F,EAAAA,aAkIDuF,EApIA,GCAAO,EAAA,WAKA,SAAAA,KAO6B,2BAP5BC,EAAAA,SAAQC,KAAA,CAAC,CACNC,UAAW,CACP,CAAEC,QAASjG,EAAgBkG,SAAUlG,GACrC,CAAEiG,QAASrI,EAAoBsI,SAAUtI,GACzC,CAAEqI,QAASX,EAAqBY,SAAUZ,QAGrBO,EAZ7B","sourcesContent":["export enum NgxPicaErrorType {\n    NO_FILES_RECEIVED = 'NO_FILES_RECEIVED',\n    CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED = 'CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED',\n    NOT_BE_ABLE_TO_COMPRESS_ENOUGH = 'NOT_BE_ABLE_TO_COMPRESS_ENOUGH'\n}\n\nexport interface NgxPicaErrorInterface {\n    err: NgxPicaErrorType;\n    file?: File;\n}\n","import {Injectable} from '@angular/core';\nimport * as EXIF from 'exif-js';\n\n\n@Injectable()\nexport class NgxPicaExifService {\n\n    public getExifOrientedImage(image: HTMLImageElement): Promise<HTMLImageElement> {\n        return new Promise<HTMLImageElement>((resolve, reject) => {\n            EXIF.getData((image as any), () => {\n                const allExifMetaData = EXIF.getAllTags(image),\n                    exifOrientation = allExifMetaData.Orientation;\n\n                if (exifOrientation) {\n\n                    if (!/^[1-8]$/.test(exifOrientation)) {\n                        throw new Error('orientation should be [1-8]');\n                    }\n\n                    const canvas: HTMLCanvasElement = document.createElement('canvas'),\n                        ctx = canvas.getContext('2d');\n\n                    let deg = 0,\n                        cx = 0,\n                        cy = 0,\n                        width: number = image.width,\n                        height: number = image.height;\n\n                    if ([5, 6, 7, 8].indexOf(exifOrientation) > -1) {\n                        width = image.height;\n                        height = image.width;\n                    }\n\n                    canvas.width = width;\n                    canvas.height = height;\n\n                    switch (exifOrientation) {\n                        case 3:\n                        case 4:\n                            cx = -image.width;\n                            cy = -image.height;\n                            deg = 180;\n                            break;\n                        case 5:\n                        case 6:\n                            cy = -image.height;\n                            deg = 90;\n                            break;\n                        case 7:\n                        case 8:\n                            cx = -image.width;\n                            deg = 270;\n                            break;\n                        default:\n                            break;\n                    }\n\n                    if ([2, 4, 5, 7].indexOf(exifOrientation) > -1) {\n                        ctx.translate(width, 0);\n                        ctx.scale(-1, 1);\n                    }\n\n                    ctx.rotate(deg / 180 * Math.PI);\n                    ctx.drawImage(image, cx, cy);\n\n                    const img = new Image();\n\n                    img.width = width;\n                    img.height = height;\n\n                    img.onload = () => {\n                        resolve(img);\n                    };\n\n                    img.src = canvas.toDataURL();\n                } else {\n                    resolve(image);\n                }\n            });\n        });\n    }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Subject, Observable, Subscription } from 'rxjs';\nimport { NgxPicaErrorInterface, NgxPicaErrorType } from './ngx-pica-error.interface';\nimport { NgxPicaResizeOptionsInterface } from './ngx-pica-resize-options.interface';\nimport { NgxPicaExifService } from './ngx-pica-exif.service';\nimport Pica from 'pica/dist/pica.js';\n\ndeclare let window: any;\n\n@Injectable()\nexport class NgxPicaService {\n    private picaResizer = new Pica();\n    private MAX_STEPS = 20;\n\n    constructor(private _ngxPicaExifService: NgxPicaExifService) {\n        if (!this.picaResizer || !this.picaResizer.resize) {\n            this.picaResizer = new window.Pica();\n        }\n    }\n\n    public resizeImages(files: File[], width: number, height: number, options?: NgxPicaResizeOptionsInterface): Observable<File> {\n        const resizedImage: Subject<File> = new Subject();\n        const totalFiles: number = files.length;\n\n        if (totalFiles > 0) {\n            const nextFile: Subject<File> = new Subject();\n            let index = 0;\n\n            const subscription: Subscription = nextFile.subscribe((file: File) => {\n                this.resizeImage(file, width, height, options).subscribe(imageResized => {\n                    index++;\n                    resizedImage.next(imageResized);\n\n                    if (index < totalFiles) {\n                        nextFile.next(files[index]);\n\n                    } else {\n                        resizedImage.complete();\n                        subscription.unsubscribe();\n                    }\n                }, (err) => {\n                    const ngxPicaError: NgxPicaErrorInterface = {\n                        file: file,\n                        err: err\n                    };\n\n                    resizedImage.error(ngxPicaError);\n                });\n            });\n\n            nextFile.next(files[index]);\n        } else {\n            const ngxPicaError: NgxPicaErrorInterface = {\n                err: NgxPicaErrorType.NO_FILES_RECEIVED\n            };\n\n            resizedImage.error(ngxPicaError);\n            resizedImage.complete();\n        }\n\n        return resizedImage.asObservable();\n    }\n\n    public resizeImage(\n        file: File,\n        width: number,\n        height: number,\n        options?: NgxPicaResizeOptionsInterface\n    ): Observable<File> {\n        const resizedImage: Subject<File> = new Subject();\n        const originCanvas: HTMLCanvasElement = document.createElement('canvas');\n        const ctx = originCanvas.getContext('2d');\n        const img = new Image();\n\n        if (ctx) {\n            img.onload = () => {\n                this._ngxPicaExifService.getExifOrientedImage(img).then(orientedImage => {\n                    window.URL.revokeObjectURL(img.src);\n                    originCanvas.width = orientedImage.width;\n                    originCanvas.height = orientedImage.height;\n\n                    ctx.drawImage(orientedImage, 0, 0);\n\n                    const imageData = ctx.getImageData(0, 0, orientedImage.width, orientedImage.height);\n                    if (options && options.aspectRatio && options.aspectRatio.keepAspectRatio) {\n                        let ratio = 0;\n\n                        if (options.aspectRatio.forceMinDimensions) {\n                            ratio = Math.max(width / imageData.width, height / imageData.height);\n                        } else {\n                            ratio = Math.min(width / imageData.width, height / imageData.height);\n                        }\n\n                        width = Math.round(imageData.width * ratio);\n                        height = Math.round(imageData.height * ratio);\n                    }\n\n                    const destinationCanvas: HTMLCanvasElement = document.createElement('canvas');\n                    destinationCanvas.width = width;\n                    destinationCanvas.height = height;\n\n                    this.picaResize(file, originCanvas, destinationCanvas, options)\n                        .catch((err) => resizedImage.error(err))\n                        .then((imgResized: File) => {\n                            resizedImage.next(imgResized);\n                        });\n                });\n            };\n\n            img.src = window.URL.createObjectURL(file);\n        } else {\n            resizedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);\n        }\n\n        return resizedImage.asObservable();\n    }\n\n    public compressImages(files: File[], sizeInMB: number): Observable<File> {\n        const compressedImage: Subject<File> = new Subject();\n        const totalFiles: number = files.length;\n\n        if (totalFiles > 0) {\n            const nextFile: Subject<File> = new Subject();\n            let index = 0;\n\n            const subscription: Subscription = nextFile.subscribe((file: File) => {\n                this.compressImage(file, sizeInMB).subscribe(imageCompressed => {\n                    index++;\n                    compressedImage.next(imageCompressed);\n\n                    if (index < totalFiles) {\n                        nextFile.next(files[index]);\n\n                    } else {\n                        compressedImage.complete();\n                        subscription.unsubscribe();\n                    }\n                }, (err) => {\n                    const ngxPicaError: NgxPicaErrorInterface = {\n                        file: file,\n                        err: err\n                    };\n\n                    compressedImage.error(ngxPicaError);\n                });\n            });\n\n            nextFile.next(files[index]);\n        } else {\n            const ngxPicaError: NgxPicaErrorInterface = {\n                err: NgxPicaErrorType.NO_FILES_RECEIVED\n            };\n\n            compressedImage.error(ngxPicaError);\n            compressedImage.complete();\n        }\n\n        return compressedImage.asObservable();\n    }\n\n    public compressImage(file: File, sizeInMB: number): Observable<File> {\n        const compressedImage: Subject<File> = new Subject();\n\n        if (this.bytesToMB(file.size) <= sizeInMB) {\n            setTimeout(() => {\n                compressedImage.next(file);\n            });\n        } else {\n\n            const originCanvas: HTMLCanvasElement = document.createElement('canvas');\n            const ctx = originCanvas.getContext('2d');\n            const img = new Image();\n\n            if (ctx) {\n                img.onload = () => {\n                    this._ngxPicaExifService.getExifOrientedImage(img).then(orientedImage => {\n                        window.URL.revokeObjectURL(img.src);\n                        originCanvas.width = orientedImage.width;\n                        originCanvas.height = orientedImage.height;\n\n                        ctx.drawImage(orientedImage, 0, 0);\n\n                        this.getCompressedImage(originCanvas, file.type, 1, sizeInMB, 0)\n                            .catch((err) => compressedImage.error(err))\n                            .then((blob: Blob) => {\n                                const imgCompressed: File = this.blobToFile(blob, file.name, file.type, new Date().getTime());\n\n                                compressedImage.next(imgCompressed);\n                            });\n                    });\n                };\n\n                img.src = window.URL.createObjectURL(file);\n            } else {\n                compressedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);\n            }\n        }\n\n        return compressedImage.asObservable();\n    }\n\n    private getCompressedImage(\n        canvas: HTMLCanvasElement,\n        type: string,\n        quality: number,\n        sizeInMB: number,\n        step: number\n    ): Promise<Blob> {\n        return new Promise<Blob>((resolve, reject) => {\n            this.picaResizer.toBlob(canvas, type, quality)\n                .catch((err) => reject(err))\n                .then((blob: Blob) => {\n                    this.checkCompressedImageSize(canvas, blob, quality, sizeInMB, step)\n                        .catch((err) => reject(err))\n                        .then((compressedBlob: Blob) => {\n                            resolve(compressedBlob);\n                        }\n                        );\n                });\n        });\n    }\n\n    private checkCompressedImageSize(\n        canvas: HTMLCanvasElement,\n        blob: Blob,\n        quality: number,\n        sizeInMB: number,\n        step: number\n    ): Promise<Blob> {\n        return new Promise<Blob>((resolve,\n            reject) => {\n\n            if (step > this.MAX_STEPS) {\n                reject(NgxPicaErrorType.NOT_BE_ABLE_TO_COMPRESS_ENOUGH);\n            } else if (this.bytesToMB(blob.size) < sizeInMB) {\n                resolve(blob);\n            } else {\n                const newQuality: number = quality - (quality * 0.1);\n                const newStep: number = step + 1;\n\n                // recursively compression\n                resolve(this.getCompressedImage(canvas, blob.type, newQuality, sizeInMB, newStep));\n            }\n        });\n    }\n\n    private picaResize(file: File, from: HTMLCanvasElement, to: HTMLCanvasElement, options: any): Promise<File> {\n        return new Promise<File>((resolve, reject) => {\n            this.picaResizer.resize(from, to, options)\n                .catch((err) => reject(err))\n                .then((resizedCanvas: HTMLCanvasElement) => this.picaResizer.toBlob(resizedCanvas, file.type))\n                .then((blob: Blob) => {\n                    const fileResized: File = this.blobToFile(blob, file.name, file.type, new Date().getTime());\n                    resolve(fileResized);\n                });\n        });\n    }\n\n    private blobToFile(blob: Blob, name: string, type: string, lastModified: number): File {\n        return new File([blob], name, { type: type, lastModified: lastModified });\n    }\n\n    private bytesToMB(bytes: number) {\n        return bytes / 1048576;\n    }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class NgxPicaImageService {\n\n    private imageExtensions: string[] = [\n        'ase',\n        'art',\n        'bmp',\n        'blp',\n        'cd5',\n        'cit',\n        'cpt',\n        'cr2',\n        'cut',\n        'dds',\n        'dib',\n        'djvu',\n        'egt',\n        'exif',\n        'gif',\n        'gpl',\n        'grf',\n        'icns',\n        'ico',\n        'iff',\n        'jng',\n        'jpeg',\n        'jpg',\n        'jfif',\n        'jp2',\n        'jps',\n        'lbm',\n        'max',\n        'miff',\n        'mng',\n        'msp',\n        'nitf',\n        'ota',\n        'pbm',\n        'pc1',\n        'pc2',\n        'pc3',\n        'pcf',\n        'pcx',\n        'pdn',\n        'pgm',\n        'PI1',\n        'PI2',\n        'PI3',\n        'pict',\n        'pct',\n        'pnm',\n        'pns',\n        'ppm',\n        'psb',\n        'psd',\n        'pdd',\n        'psp',\n        'px',\n        'pxm',\n        'pxr',\n        'qfx',\n        'raw',\n        'rle',\n        'sct',\n        'sgi',\n        'rgb',\n        'int',\n        'bw',\n        'tga',\n        'tiff',\n        'tif',\n        'vtf',\n        'xbm',\n        'xcf',\n        'xpm',\n        '3dv',\n        'amf',\n        'ai',\n        'awg',\n        'cgm',\n        'cdr',\n        'cmx',\n        'dxf',\n        'e2d',\n        'egt',\n        'eps',\n        'fs',\n        'gbr',\n        'odg',\n        'svg',\n        'stl',\n        'vrml',\n        'x3d',\n        'sxd',\n        'v2d',\n        'vnd',\n        'wmf',\n        'emf',\n        'art',\n        'xar',\n        'png',\n        'webp',\n        'jxr',\n        'hdp',\n        'wdp',\n        'cur',\n        'ecw',\n        'iff',\n        'lbm',\n        'liff',\n        'nrrd',\n        'pam',\n        'pcx',\n        'pgf',\n        'sgi',\n        'rgb',\n        'rgba',\n        'bw',\n        'int',\n        'inta',\n        'sid',\n        'ras',\n        'sun',\n        'tga'\n    ];\n\n    public isImage(file: File): boolean {\n        const fileExtension: string = file.name.toLowerCase().substr(file.name.lastIndexOf('.') + 1);\n        return (this.imageExtensions.indexOf(fileExtension) !== -1);\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { NgxPicaService } from './ngx-pica.service';\nimport { NgxPicaExifService } from './ngx-pica-exif.service';\nimport { NgxPicaImageService } from './ngx-pica-image.service';\n\n@NgModule({\n    providers: [\n        { provide: NgxPicaService, useClass: NgxPicaService },\n        { provide: NgxPicaExifService, useClass: NgxPicaExifService },\n        { provide: NgxPicaImageService, useClass: NgxPicaImageService },\n    ]\n})\nexport class NgxPicaModule { }\n"]}